\section{Introduction}

Since Bitcoin was first introduced in 2009, decentralized transaction systems have surged in popularity in both the academic and private sectors \cite{nakamoto2008bitcoin}. To maintain decentralization, these systems rely on a consensus ledger maintained solely by the users, and thus no centralized institution is required to maintain it. Blockchains were created as a way to handle the intricacies of a decentralized ledger system for transactions; however, today blockchains are used for much more. Miller et al. demonstrated a way to preserve data using blockchains by incentivizing users to store large volumes of data rather than provide large amount of computing power \cite{miller2014permacoin}, and use cases have been proposed to built entire operating systems from the blockchain structure \cite{factombos,tapscott2016blockchain}. However, with no central force governing these tools, new problems arise when handling secure and trusted transactions, data transfers, and events. \\

Thus, smart contracts were developed to provide a secure way to handle events in decentralized systems. A smart contract follows the success of Bitcoin's consensus ledger by providing a "consensus protocol" that a blockchain decides upon to guarantee any event between two entities is handled without third party intervention and results in costly penalties for any party found in breach of the contract \cite{szabo1997idea, luu2016making,daian2016dao}. These contracts can be used for transactions between two people, allow for digital identities, and facilitate data sharing. An example of a smart contract is shown in figure \ref{code:example}. In this example we have a basic script that sends money only if the condition \texttt{defined\_condition.is\_met()} succeeds. This condition can be any collection of jointly agreed upon requirements, and thus a wide array of contracts can be decentralized using smart contracts. \\

Unfortunately, the current state of smart contract code quality is remarkably dismal. Solidity, the most popular smart contract programming language, was created to be similar to JavaScript and attract as many users as possible \cite{bartolettipompianuanalysis, systematicstudy}. Many developers on Solidity are drawn in by the sensationalized articles of blockchain and ``Hello World'' applications are everywhere to be found. Many developers do not know about the specifics of Solidity and the many pitfalls. One of the biggest pitfalls is that many functions can fail \cite{systematicstudy}. Most notably, the send function -- the function that sends money from one account to another, can fail. When this happens, it is currently the developer's responsibility to roll back what has happened appropriately \cite{luu2016making}. In fact, this has been the cause for many significant attacks on the Ethereum network. \\

\begin{figure}[h!]
\lstinputlisting[language=C]{code/example.txt} 
\label{code:example}
\caption{An example of a smart contract that sends money if a certain condition is met; allowing for many types of contracts.}
\end{figure}

By nature of the blockchain, developing decentralized applications is quite different from that of normal development. Since the blockchain is created to be immutable, patches are issued as new versions of the same program, and everyone is encouraged to switch over. However, the old version of an application or contract is still accessible on the global database, the ledger. Additionally, it takes time for an application to spread throughout the network \cite{luu2016making}. This inability to roll back increases the importance of getting code right on the first try \cite{luu2016making}. \\

Luckily, many researchers have worked to mitigate these attacks by providing code analysis tools. These analysis tools cover a wide variety of bugs and coding styles to promote clean, readable code\cite{atzei2017survey}. Unfortunately, not all of these tools are easy to use and many are poorly documented. This is where our tool comes in play. \\

Our tool works by allowing people to run their code on a variety of testing tools. By making this process as simple as selecting a set of testing suites, the users can easily see what errors are generated by what vulnerabilities and from what testing suite. Additionally, we are working to allow the user to specify code snippets of higher priority so we can rank errors in those regions higher. Another neat benefit is that many of these testing suites are still in active development, so new vulnerabilities would still be caught without any further action from the developer. In the grand scheme, we want to promote code quality and make improving code quality on smart contracts a trivial task. Hopefully this improves the state of smart contracts for the community as a whole. 
