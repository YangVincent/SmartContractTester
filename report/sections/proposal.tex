\section{Proposal}

Since Bitcoin was first introduced in 2009, decentralized transaction systems have surged in popularity in both the academic and private sectors \cite{nakamoto2008bitcoin}. To maintain decentralization, these systems rely on a consensus ledger maintained solely by the users, and thus no institution is required to maintain it. Blockchains were created as a way to handle the intricacies of a decentralized ledger system for transactions; however, today blockchains are used for much more. Miller et al. demonstrated a way to preserve data using blockchains by incentivizing users to store large volumes of data rather than provide large amount of computing power \cite{miller2014permacoin}, and use cases have been proposed to built entire operating systems from the blockchain structure \cite{factombos,tapscott2016blockchain}. However, with no central force governing these tools, new problems arise to handle secure and trusted transactions, data transfers, and events. \\


Thus, smart contracts were developed to provide a secure way to handle events in decentralized systems. A smart contract follows the success of Bitcoin's consensus ledger by providing a "consensus protocol" that a blockchain decides upon to guarantee any event between two entities is handled without third party intervention and results in costly penalties for any party found in breach of the contract \cite{szabo1997idea, luu2016making}. These contracts can be used for transactions between two people, allow for digital identities, and facilitate data sharing. To develop smart contracts, Turing-complete scripting languages were added to the Bitcoin and Ethereum blockchains \cite{buterin2014next, christidis2016blockchains, rosa2017bitcoinscript}. However, as with any other programming language, bugs and security risks were being exploited to breach contracts without incurring penalties \cite{dika2017ethereum}. \\


One such security risk is the infamous DAO attack that allowed one hacker to completely drain the available Ethereum DAO funds; at total of \$150,000,000.00. In this case, the exploited vulnerability arose from a fix to a known vulnerability in the recursive contracts allowing an attacker to repeatedly withdraw funds with a zero balance \cite{daian2016dao}. With the right tests, this bug could be caught before deployment. Thus developers are testing their code on a level that verges on obsessive; in an attempt to avoid millions of dollars of lost funds. \\


To answer this call for bug-free smart contracts, testing suites such as Oyente were developed that specialize in the unique security risks presented by decentralized contracting. Oyente is a tool that allows users to detect bugs before deploying their smart contracts on Ethereum. It employs symbolic execution specifically for the Ethereum execution model\cite{wood2014ethereum} by directly reading the Ethereum Virtual Machine (EVM) byte code. With this model, Luu et al. found that 8,833 of 19,366 contracts potentially had known bugs, which would have put at risk over 30 million dollars. Moreover, their framework can detect the DAO bug \cite{luu2016making}. However, these bugs are well documented beforehand, and in the case of the DAO bug, developers were unaware of the new risk they introduced. Thus other similar suites like Mythril have been created in an attempt to minimize these risks.\\


We seek to explore these smart contract testing solutions, and validate these tools using novel metrics that consider the bugs unique to blockchain platforms and the security problems presented by these decentralized transactional events. We propose a tool for comparing these testing suites on a specific codebase. This tool will combine visualizations of the bugs discovered by the testing suites, and explore developer driven metrics allowing specific blocks of code to be tagged with more importance. Thus, we allow developers to compare available testing options on their own codebase with metrics of far more meaning than generic code coverage. \\


