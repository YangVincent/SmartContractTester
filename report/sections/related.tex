\section{Related Work}

Recently, research into removing bugs from smart contracts has surged. This has lead to an array of tools designed to ensure the stability and accuracy of smart contracts. This has lead to three distinct schools of thought in bug detection. One method is Static analysis, where tools rely on techniques that do not require running the code, such as determining any paths that are unreachable \cite{everts2018will}. Code coverage, which is focusing solely on testing as much of a block of code as possible, and linters, a technique designed to preemptively catch bugs during development, account for the remaining tool categories \cite{manticore}. Based off studies from researchers like Kochhar et al., code coverage is known to have little to no correlation with actual bugs \cite{kochhar2017code, zhou2018security}, and linters need to be employed before development; providing no support for the extensive list of smart contracts already in use. Thus, our study focuses primarily on comparing static analysis tools through a wide array of smart contracts. \\

The current smart contract static analysis tools employ a wide variety of techniques to study the code. Mythril, Oyente, and Porosity. Each of these techniques travel branches within the solidity script, studying possible points of failure along the way. Oyente employs symbolic execution, a technique that uses symbols to determine which values traverse certain paths in the code \cite{king1976symbolic}. Mythril provides a comprehensive blockchain exploration tool that has finally allowed chain exploration to succeed in smart contract testing \cite{sen2005cute}. Porosity translates EVM bytecode into Solidity; allowing for static and dynamic analysis of the contracts \cite{porosity}. \\

Fontein studied each of these static analysis techniques in detail. In this study, he found that Oyente detects on average 75\% of the errors, but severely lacks in missed timestamp dependency bugs. Moreover, since Oyente relies on symbolic execution, a missed opportunity to provide an export of the script's control flow graph (CFG) could drastically improve it's effectiveness. Porosity's decompilation tools were shown to be very limited, and this tool only detects re-entrancy bugs. However, many of the re-entrancy bugs it detects are incorrect. Fontein defined Mythril as the clear winner as it detected the most bugs without false positives. However, Fontein did not mention the quality of the bugs, such as fixing the infamous DAO bug that cost almost 60 million in lost funds \cite{fontein2018comparison}. \\

Even with this surge in tools, smart contracts filled with bugs are still being created. This is largely due to the lack of usability within each tool. With the huge opportunity for smart contracts in the financial sectors, many non-technical developers are creating contracts of their own \cite{tapscott2016blockchain}. However, these tools require knowledge of concepts such as EVM bytecode or symbolic execution. Thus, systems have been developed to provide user friendly interfaces to these tools. SmartCheck allows users to run tools on their website with ease, but the analysis is hidden from the user on their backend. Thus, user-driven studies are limited, and focusing analysis on important aspects is difficult \cite{smartcheck}. \\

Thus, we explored these smart contract testing solutions, and validate these tools using novel metrics that consider the bugs unique to blockchain platforms and the security problems presented by these decentralized transactional events. Moreover, we developed a tool for comparing these testing suites on a specific codebase through user-driven studies. This tool combines results of the bugs discovered by the testing suites, and explores developer driven metrics allowing specific blocks of code to be tagged with more importance. This allows developers to compare available testing options on their own codebase with metrics of far more meaning than generic code coverage. With our tool, they have the ability to quickly see potential vulnerabilities in their code. \\



